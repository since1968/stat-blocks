<!DOCTYPE html>
<html><head><link href="https://fonts.googleapis.com/css?family=Libre+Baskerville:700" rel="stylesheet" type="text/css"/><link href="http://fonts.googleapis.com/css?family=Noto+Sans:400,700,400italic,700italic" rel="stylesheet" type="text/css"/><meta charset="utf-8"/><title>Two-column statblock example</title><style>
      body {
        margin: 0;
      }

      stat-block {
        /* A bit of margin for presentation purposes, to show off the drop
        shadow. */
        margin-left: 20px;
        margin-top: 20px;
      }
    </style></head><body><template id="tapered-rule">
  <style>
    svg {
      fill: #922610;
      /* Stroke is necessary for good antialiasing in Chrome. */
      stroke: #922610;
      margin-top: 0.6em;
      margin-bottom: 0.35em;
    }
  </style>
  <svg height="5" width="400">
    <polyline points="0,0 400,2.5 0,5"></polyline>
  </svg>
</template><script>
(function(window, document) {
  var elemName = 'tapered-rule';
  var thatDoc = document;
  var thisDoc = (thatDoc.currentScript || thatDoc._currentScript).ownerDocument;
  var proto = Object.create(HTMLElement.prototype, {
    createdCallback: {
      value: function() {
        var template = thisDoc.getElementById(elemName);
        var clone = thatDoc.importNode(template.content, true);
        this.createShadowRoot().appendChild(clone);
      }
    }
  });
  thatDoc.registerElement(elemName, {prototype: proto});
})(window, document);
</script><template id="top-stats">
  <style>
    ::content * {
      color: #7A200D;
    }
  </style>

  <tapered-rule></tapered-rule>
  <content></content>
  <tapered-rule></tapered-rule>
</template><script>
(function(window, document) {
  var elemName = 'top-stats';
  var thatDoc = document;
  var thisDoc = (thatDoc.currentScript || thatDoc._currentScript).ownerDocument;
  var proto = Object.create(HTMLElement.prototype, {
    createdCallback: {
      value: function() {
        var template = thisDoc.getElementById(elemName);
        var clone = thatDoc.importNode(template.content, true);
        this.createShadowRoot().appendChild(clone);
      }
    }
  });
  thatDoc.registerElement(elemName, {prototype: proto});
})(window, document);
</script><template id="creature-heading">
  <style>
    ::content > h1 {
      font-family: 'Libre Baskerville', 'Lora', 'Calisto MT',
                   'Bookman Old Style', Bookman, 'Goudy Old Style',
                   Garamond, 'Hoefler Text', 'Bitstream Charter',
                   Georgia, serif;
      color: #7A200D;
      font-weight: 700;
      margin: 0px;
      font-size: 23px;
      letter-spacing: 1px;
      font-variant: small-caps;
    }

    ::content > h2 {
      font-weight: normal;
      font-style: italic;
      font-size: 12px;
      margin: 0;
    }
  </style>
  <content select="h1"></content>
  <content select="h2"></content>
</template><script>
(function(window, document) {
  var elemName = 'creature-heading';
  var thatDoc = document;
  var thisDoc = (thatDoc.currentScript || thatDoc._currentScript).ownerDocument;
  var proto = Object.create(HTMLElement.prototype, {
    createdCallback: {
      value: function() {
        var template = thisDoc.getElementById(elemName);
        var clone = thatDoc.importNode(template.content, true);
        this.createShadowRoot().appendChild(clone);
      }
    }
  });
  thatDoc.registerElement(elemName, {prototype: proto});
})(window, document);
</script><template id="abilities-block">
  <style>
    table {
      width: 100%;
      border: 0px;
      border-collapse: collapse;
    }
    th, td {
      width: 50px;
      text-align: center;
    }
  </style>
  <tapered-rule></tapered-rule>
  <table>
    <tbody><tr>
      <th>STR</th>
      <th>DEX</th>
      <th>CON</th>
      <th>INT</th>
      <th>WIS</th>
      <th>CHA</th>
    </tr>
    <tr>
      <td id="str"></td>
      <td id="dex"></td>
      <td id="con"></td>
      <td id="int"></td>
      <td id="wis"></td>
      <td id="cha"></td>
    </tr>
  </tbody></table>
  <tapered-rule></tapered-rule>
</template><script>
(function(window, document) {
  function abilityModifier(abilityScore) {
    var score = parseInt(abilityScore, 10);
    return Math.floor((score - 10) / 2);
  }

  function formattedModifier(abilityModifier) {
    if (abilityModifier >= 0) {
      return '+' + abilityModifier;
    }
    // This is an en dash, NOT a "normal" dash. The minus sign needs to be more
    // visible.
    return 'â€“' + Math.abs(abilityModifier);
  }

  function abilityText(abilityScore) {
    return [String(abilityScore),
            ' (',
            formattedModifier(abilityModifier(abilityScore)),
            ')'].join('');
  }

  var elemName = 'abilities-block';
  var thatDoc = document;
  var thisDoc = (thatDoc.currentScript || thatDoc._currentScript).ownerDocument;
  var proto = Object.create(HTMLElement.prototype, {
    createdCallback: {
      value: function() {
        var template = thisDoc.getElementById(elemName);
        var clone = thatDoc.importNode(template.content, true);
        var root = this.createShadowRoot().appendChild(clone);
      }
    },
    attachedCallback: {
      value: function() {
        var root = this.shadowRoot;
        for (var i = 0; i < this.attributes.length; i++) {
          var attribute = this.attributes[i];
          var abilityShortName = attribute.name.split('-')[1];
          root.getElementById(abilityShortName).textContent =
             abilityText(attribute.value);
        }

      }
    }
  });
  thatDoc.registerElement(elemName, {prototype: proto});
})(window, document);
</script><template id="property-line">
  <style>
    :host {
      line-height: 1.4;
      display: block;
      text-indent: -1em;
      padding-left: 1em;
    }

    ::content > h4 {
      margin: 0;
      display: inline;
      font-weight: bold;
    }

    ::content > p:first-of-type {
      display: inline;
      text-indent: 0;
    }

    ::content > p {
      text-indent: 1em;
      margin: 0;
    }
  </style>
  <content></content>
</template><script>
(function(window, document) {
  var elemName = 'property-line';
  var thatDoc = document;
  var thisDoc = (thatDoc.currentScript || thatDoc._currentScript).ownerDocument;
  var proto = Object.create(HTMLElement.prototype, {
    createdCallback: {
      value: function() {
        var template = thisDoc.getElementById(elemName);
        var clone = thatDoc.importNode(template.content, true);
        this.createShadowRoot().appendChild(clone);
      }
    }
  });
  thatDoc.registerElement(elemName, {prototype: proto});
})(window, document);
</script><template id="property-block">
  <style>
    :host {
      margin-top: 0.3em;
      margin-bottom: 0.9em;
      line-height: 1.5;
      display: block;
    }

    ::content > h4 {
      margin: 0;
      display: inline;
      font-weight: bold;
      font-style: italic;
    }

    ::content > p:first-of-type {
      display: inline;
      text-indent: 0;
    }

    ::content > p {
      text-indent: 1em;
      margin: 0;
    }
  </style>
  <content></content>
</template><script>
(function(window, document) {
  var elemName = 'property-block';
  var thatDoc = document;
  var thisDoc = (thatDoc.currentScript || thatDoc._currentScript).ownerDocument;
  var proto = Object.create(HTMLElement.prototype, {
    createdCallback: {
      value: function() {
        var template = thisDoc.getElementById(elemName);
        var clone = thatDoc.importNode(template.content, true);
        this.createShadowRoot().appendChild(clone);
      }
    }
  });
  thatDoc.registerElement(elemName, {prototype: proto});
})(window, document);
</script><template id="content-column">
  <style>
    :host {
      display: block;
      width: 400px;
    }

    ::content > h3 {
      border-bottom: 1px solid #7A200D;
      color: #7A200D;
      font-size: 21px;
      font-variant: small-caps;
      font-weight: normal;
      letter-spacing: 1px;
      margin: 0;
      margin-bottom: 0.3em;
    }

    /* For user-level p elems. */
    ::content > p {
      margin-top: 0.3em;
      margin-bottom: 0.9em;
      line-height: 1.5;
    }

    /* Last child shouldn't have bottom margin, too much white space. */
    ::content > *:last-child {
      margin-bottom: 0;
    }

    /* If anything but a <creature-heading> is the first child, then we are the
    second column and thus the first item should have no top margin. */
    ::content > :not(creature-heading):first-child {
      margin-top: 0;
    }
  </style>
  <content></content>
</template><script>
(function(window, document) {
  var elemName = 'content-column';
  var thatDoc = document;
  var thisDoc = (thatDoc.currentScript || thatDoc._currentScript).ownerDocument;
  var proto = Object.create(HTMLElement.prototype, {
    createdCallback: {
      value: function() {
        var template = thisDoc.getElementById(elemName);
        var clone = thatDoc.importNode(template.content, true);
        this.createShadowRoot().appendChild(clone);
      }
    }
  });
  thatDoc.registerElement(elemName, {prototype: proto});
})(window, document);
</script><template id="stat-block">
  <style>
    :host {
      display: block;
    }

    #outer-wrap {
      display: inline-block;
    }

    #content-wrap {
      font-family: 'Noto Sans', 'Myriad Pro', Calibri, Helvetica, Arial,
                    sans-serif;
      font-size: 13.5px;
      display: flex;
      justify-content: space-between;
      background: #FDF1DC;
      padding: 0.6em;
      padding-bottom: 0.5em;
      border: 1px #DDD solid;
      box-shadow: 0 0 1.5em #867453;

      /* We don't want the box-shadow in front of the bar divs. */
      position: relative;
      z-index: 0;

      /* Leaving room for the two bars to protrude outwards */
      margin-left: 2px;
      margin-right: 2px;
    }

    ::content > content-column + content-column {
      margin-left: 40px;
    }

    .bar {
      height: 5px;
      background: #E69A28;
      border: 1px solid #000;
      position: relative;
      z-index: 1;
    }
  </style>
  <div id="outer-wrap">
    <div class="bar"></div>
    <div id="content-wrap">
      <content></content>
    </div>
    <div class="bar"></div>
  </div>
</template><script>
(function(window, document) {
  var elemName = 'stat-block';
  var thatDoc = document;
  var thisDoc = (thatDoc.currentScript || thatDoc._currentScript).ownerDocument;
  var proto = Object.create(HTMLElement.prototype, {
    createdCallback: {
      value: function() {
        var template = thisDoc.getElementById(elemName);

        // We support not wrapping the contents inside <stat-block> with
        // <content-column> to simplify the most common use-case of only a
        // single column. If the user doesn't do the wrapping, we do it for
        // them.
        if (this.firstElementChild.tagName !== 'CONTENT-COLUMN') {
          var wrap = template.content.getElementById('content-wrap');
          wrap.innerHTML = '<content-column>' + wrap.innerHTML +
                           '</content-column>';
        }
        var clone = thatDoc.importNode(template.content, true);
        this.createShadowRoot().appendChild(clone);
      }
    }
  });
  thatDoc.registerElement(elemName, {prototype: proto});
})(window, document);
</script>
  


<stat-block>
    <content-column>
      <creature-heading>
        <h1>Werewolf Alpha</h1>
        <h2>Medium humanoid (human, shapechanger), chaotic evil</h2>
      </creature-heading>

      <top-stats>
        <property-line>
          <h4>Armor Class</h4>
          <p>14 (armor scraps) in humanoid form, 16 (natural armor) in wolf
            or hybrid form</p>
        </property-line>
        <property-line>
          <h4>Hit Points</h4>
          <p>119 (14d8 + 56)</p>
        </property-line>
        <property-line>
          <h4>Speed</h4>
          <p>30 ft. (40 ft. in wolf form)</p>
        </property-line>

        <abilities-block data-cha="15" data-con="18" data-dex="15" data-int="11" data-str="20" data-wis="14"></abilities-block>
        <property-line>
          <h4>Saving Throws</h4>
          <p>Str +9, Con +8, Wis +6</p>
        </property-line>
        <property-line>
          <h4>Skills</h4>
          <p>Athletics +9, Perception +6</p>
        </property-line>
        <property-line>
          <h4>Damage Immunities</h4>
          <p>bludgeoning, piercing, and slashing damage from nonmagical weapons
            that aren't silvered</p>
        </property-line>
        <property-line>
          <h4>Senses</h4>
          <p>passive Perception 16</p>
        </property-line>
        <property-line>
          <h4>Languages</h4>
          <p>Common (can't speak in wolf form)</p>
        </property-line>
        <property-line>
          <h4>Challenge</h4>
          <p>9 (5,000 XP)</p>
        </property-line>
      </top-stats>


      <property-block>
        <h4>Legendary Resistance (3/Day).</h4>
        <p>If the werewolf fails a saving throw, it can choose to succeed
          instead.</p>
      </property-block>

      <property-block>
        <h4>Keen Hearing and Smell.</h4>
        <p>The werewolf has advantage on Wisdom (Perception) checks that rely on
          hearing or smell.</p>
      </property-block>

      <property-block>
        <h4>Pack Leader.</h4>
        <p>The werewolf's allies have advantage on melee attack rolls against
          any hostile creature within 5 feet of the werewolf.</p>
      </property-block>

      <property-block>
        <h4>Shapechanger.</h4>
        <p>The werewolf can use its action to polymorph into a wolf-humanoid
          hybrid or into a wolf, or back into its true form, which is humanoid.
          Its statistics, other than its AC, are the same in each form. Any
          equipment it is wearing or carrying isn't transformed. It reverts to
          its true form if it dies.</p>
      </property-block>
    </content-column>

    <content-column>
      <h3>Actions</h3>

      <property-block>
        <h4>Multiattack (Hybrid Form Only).</h4>
        <p>The werewolf makes three attacks: one with its bite and two with its
          claws.</p>
      </property-block>

      <property-block>
        <h4>Bite (Wolf or Hybrid Form Only).</h4>
        <p><i>Melee Weapon Attack:</i> +9 to hit, reach 5 ft., one target.
          <i>Hit:</i> 14 (2d8 + 5) piercing damage. If the target is a humanoid,
          it must succeed on a DC 14 Constitution saving throw or be cursed with
          werewolf lycanthropy.</p>
      </property-block>

      <property-block>
        <h4>Claws (Hybrid Form Only).</h4>
        <p><i>Melee Weapon Attack:</i> +9 to hit, reach 5 ft., one target.
          <i>Hit:</i> 16 (2d10 + 5) slashing damage.</p>
      </property-block>

      <h3>Legendary Actions</h3>
      <p>The werewolf can take 3 legendary actions, choosing from the
      options below. Only one legendary action option can be used at a
      time and only at the end of another creature's turn. The werewolf
      regains spent legendary actions at the start of its turn.</p>

      <property-line>
        <h4>Leap.</h4>
        <p>The werewolf moves up to its speed without provoking
          opportunity attacks.</p>
      </property-line>

      <property-line>
        <h4>Bark Orders.</h4>
        <p>The werewolf chooses a friendly creature who can
          see or hear it. That creature can use its reaction to move up to its
          speed without provoking opportunity attacks.</p>
      </property-line>

      <property-line>
        <h4>Frenzy (Costs 2 Actions).</h4>
        <p>The werewolf can make one claw attack against each creature within 5
          feet of it.</p>
      </property-line>
  </content-column></stat-block></body></html>
